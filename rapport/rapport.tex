\documentclass[12pt]{article}

\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}

\usepackage{graphicx}
\usepackage{lmodern}

\geometry{margin=2cm}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}
\noindent\includegraphics[width=0.25\textwidth]{enseirb-matmeca}

\vspace{\stretch{1}}

\begin{center}
    {\Huge\textbf{Projet de compilation}

\vspace{\stretch{1}}

    \textbf{Rubic}}
\end{center}

\vspace{\stretch{2}}

\begin{tabular}{r@{:~}l}
	\textbf{Auteurs} & \textit{David Bitonneau, Benoît Ruelle}\\
	\textbf{Encadrant} & \textit{M. Denis Barthou}\\
\end{tabular}

\vspace{\stretch{1}}

\begin{center}Deuxième année, filière informatique

    Date : \today
\end{center}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

Ce projet a pour but de créer un compilateur pour le langage Rubic, un dérivé
simplifié du langage Ruby. Le code généré est un code assembleur intermédiaire
portable pour LLVM.

\section{Langage Rubic}

En Ruby les noms de variables sont des étiquettes sans type et ce sont les
objets qu'elles contiennent qui sont fortement et dynamiquement typé. Il n'y a
donc pas de vérification de typage statique et c'est à l'exécution qu'il est
vérifié si l'appel de méthode fonctionne pour l'objet traité. Une même
variable peut donc contenir des objets de types différents au cours de sa vie.

En Rubic, le typage n'est pas dynamique mais il est implicite. Une des
difficultés du projet est de savoir reconaître le type des variables et de
générer le code statique correspondant.

\paragraph{} En Rubic il existe différents types de variables :
\begin{itemize}
    \item les nombres entiers ;
    \item les nombres flottants ;
    \item les booléens ;
    \item les chaînes de caractères ;
    \item les objets\footnote{En Ruby tout est un objet, même les classes et
        les entiers.}.
\end{itemize}

\paragraph{}
Ces variables peuvent avoir différentes portées :
\begin{itemize}
    \item Les variables qui commencent par un '\$' sont des variables
        globales, elles sont accessibles partout une fois qu'elles ont été
        définies.
    \item Les variables qui commencent par un '@' sont des variables
        d'instances, leur portée est limitée à l'objet et elles ne peuvent
        être accédées à l'extérieur que via des méthodes.
    \item Les autres variables sont locales aux environnements auxquelles
        elles appartiennent. Par exemple elles peuvent être locale à la
        fonction dans laquelle elles ont été définies ou si elles ont été
        définies à l'extérieur de toute fonction ou classe, elles ne peuvent
        être accédées à l'intérieur de ces dernière.
\end{itemize}

\paragraph{}
Enfin, par convention, les variables dont le nom commence par une majuscule
sont des constantes. En Ruby, leur modification entraine seulement l'affichage
d'un avertissement et est effective. \textbf{[En Rubic, nous avons décidé de
déclencher une erreur de compilation lorsqu'une constante est modifiée, ce qui
signifie que le processus de compilation ne s'achèvera pas.{\Large/}En
Rubic nous avons pris la même décision, seul une message d'avertissement est
affiché lorsque des constantes sont modifiées et la compilation s'achèvera
normalement.}]\emph{(rayer la mention inutile)}


\section{Analyse sémantique}

La grammaire nous étant fournie, la mojorité du travail fut de rajouter des
actions sémantique dans le parser. Nous avons tout de même complété la
grammaire pour inclure les booléens par exemple.

\subsection{Tables de hashage}

Notre compilateur propose trois espaces de noms : un pour les
variables, un autre pour les fonctions et un dernier pour les classes. Cela
permet à une variable de coexister avec une classe ou une fonction du même
nom. Chaque espace de nom est implémenté à l'aide d'une table de hashage dont
le fonctionnement est le suivant.

Deux éléments sont demandés : un identificateur et un pointeur vers une donnée.
Une clé est obtenue en sommant tous les octets de l'identificateur modulo la
taille de la table de hashage (constante fixée à la compilation). Pour prendre
en charge les éventuelles collisions, à chaque case de la table correspond une
liste chaînée (une LIFO pour réutiliser ce qui a déjà été implémenté) où sont
insérés les données ayant la même clé (eg. "toto" et "otto" produisent la même
clé) et les identifiants avant le hashage sont alors conservés dans la liste
pour distinguer deux éléments lors de la recherche. La recherche est alors
simple : à partir de l'identifiant recherché, reproduire la clé et parcourir
la liste dans la case de la table de hashage correspondante.


\subsection{Visibilité des symboles}

La visibilité des symboles a été prise en charge à l'aide d'une pile et d'une
structure appelée "block" comprenant trois tables de hashage (une par espace
de nom). Un nouveau bloc est empilé à chaque fois qu'un lexème définissant une
nouvelle visibilité est lu.

La recherche d'un symbole se fait en parcourant la pile pour
tester sa présence dans la table de hashage du type correspondant dans chaque
bloc.

%\begin{verbatim}
%IF
%    { nouveau bloc pour IF afin de stocker les éléments de expr
%      qui doit rester visible dans le THEN et dans le ELSE }
%expr
%THEN
%    { nouveau bloc pour stocker les éléments du bloc IF }
%stmts
%terms
%ELSE
%    { dépiler le bloc THEN et créer un nouveau bloc pour le ELSE.
%      ici le bloc du IF contenant les éléments de expr est toujours
%      visible. }
%stmts
%terms
%END
%    { dépiler le bloc ELSE et celui du IF }
%\end{verbatim}


\subsection{Reconnaissance et calculs sur les types}

\paragraph{} Nous avons développé un jeu de fonctions décrivant un langage intermédiaire
proche de l'assembleur LLVM dont l'intérêt est multiple. Ce jeu d'instructions
permet de manipuler le code à générer en faisant abstraction temporairement
des types des variables. Cela simplifie la génération de toutes les variantes
d'une fonction possible en fonction du type de ses paramètres et cela pose une
base sur laquelle construire le support des classes.

Ce jeu d'instruction manipule trois structures différentes :
\begin{itemize}
	\item Les constantes obtenues via les tokens STRING, FLOAT, BOOL, INT
	\item Les registres qui correspondent à un registre dans LLVM.
	\item Les variables repérées par le token ID de certaines règles (affectation, paramètres, etc).
\end{itemize}

\paragraph{} Les types possibles pour chaque variables sont calculés au fur et à mesure que
le code est lu en se basant sur les opérations dans léquelles elles
apparaîssent. Ansi, un pointeur vers une variable apparaît dans une série
d'instructions. Parmis elles, certaines nous permettent de réaliser des
calculs sur les types. Par exemple, l'emploi d'une variable aver l'opérateur
'+' permet de réduire cet ensemble aux types entier et flotant. Nous avons défini plusieurs sortes d'instruction:
\begin{itemize}
	\item Celles définissant des opérations sur des variables ou des registres
		telles que les additions ou les comparaisons.
	\item Celles pouvant insérer des instructions supplémentaires lors de la
		génération du code suivant le types d'une variable ou d'un registre.
		Nous les utilisons par exemple pour convertir un entier en booléen
		lorsqu'il est utilisé dans une condition.
	\item Celles qui stockent simplement une chaîne de caractères à imprimer
		(utilisé pour le placement de labels par exemple).
	\item Celles permettant d'établir un lien entre des registres et une
		variables (load et store).
\end{itemize}

\paragraph{} Les registres peuvent être liés une unique fois à une variable
lors d'un 'store' ou d'un 'load'. Ils partagent alors avec la variable
l'ensemble des types possible et les déductions sur le type de l'un affectera
dans le même temps celui de l'autre. Ainsi, toutes les instructions ayant un
lien direct avec une variable ou l'un de des registres qui lui sont liés sont
affectées et l'ensemble des variations du code final à générer est réduit.

\subsection{Structures de contrôle}

\paragraph{} En ruby, les structures de controles de definissent pas un bloc séparé de la fonction et il est donc nécessaire de repérer les variables introduites dans ces blocs (qui sont d'ailleurs exécutés sous conditions) pour allouer l'espace necessaire en début de fonction sous peine de créer une erreur de compilation de LLVM à cause d'allocations soumises à condition.

\paragraph{} Dans une première version du compilateur, nous avons tenté de gérer proprement le problème en forçant la déclaration des variables en dehors des structures de contrôle à l'aide de blocs définissant une nouvelle portée. Cependant, après l'introduction de notre jeu d'instruction intermédiaire nous pouvions désormais réordonner les actions à loisir. Ainsi, nous avons rendu possible la déclaration de variables dans une structure de contrôle. Il suffit pour cela de stocker dans l'ordre les instructions rencontrées dans une fonction et de mettre au début toutes celles faisant des allocations lors de la génération de l'assembleur llvm.

\paragraph{Exemple} Code original et code généré

\vspace{0.5cm}

\begin{minipage}{0.48\textwidth}
\begin{verbatim}
if true then
    a = 1
else
    b = 5
end
\end{verbatim}
\end{minipage}
\begin{minipage}{0.48\textwidth}
\begin{verbatim}
%a = alloca i32
%b = alloca i32
%r1 = or i1 true, false
br i1 %r1, label %IfTrue1, label %IfFalse1
IfTrue1:
    %r2 = add i32 1, 0
    store i32 %r2, i32* %a
    br label %EndIf1
IfFalse1:
    %r3 = add i32 5, 0
    store i32 %r3, i32* %b
    br label %EndIf1
EndIf1:
\end{verbatim}
\end{minipage}

\vspace{0.5cm}

En testant la valeur de \verb!a! et de \verb!b!, \verb!a! vaut \verb!1! et \verb!b! vaut \verb!0!. LLVM semble initiliser la memoire à 0 lors d'allocations.

\subsection{Conversion vers les booléens}

Lors de l'utilisation de variables ou de constantes dans une expression servant de condition à une structure de contrôle, il peut être nécessaire de convertir un entier ou un flotant en booléen. Nous voulions qu'un nombre valant 0 soit assimilé à faux et tous les autres (y compris les nombres négatifs) à vrai. La détection du besoin de réaliser une conversion se fait en fonction du type d'expression recontrée : une opération booléenne bit à bit ou une comparaison de nombres garantit de retourner un booléen. En revanche une expression retournant un nombre nécessite une conversion explicite et une opération de conversion est insérée. Cette dernière entraîne la création d'un nouveau registre dans l'assembleur llvm qui est substitué au registre de l'expression initiale lors du test de la structure de contrôle.

\paragraph{Exemple} Code original et code généré

\vspace{0.5cm}

\begin{minipage}{0.48\textwidth}
\begin{verbatim}
b = 5
a = 1

while b
    a = a*b
    b = b - 1
end

puts a
\end{verbatim}
\end{minipage}
\begin{minipage}{0.48\textwidth}
\begin{verbatim}
%b = alloca i32
%a = alloca i32
%r1 = add i32 5, 0
store i32 %r1, i32* %b
%r2 = add i32 1, 0
store i32 %r2, i32* %a
br label %loop1
loop1:
    %r3 = load i32* %b
    %r4 = icmp ne i32 %r3, 0
    br i1 %r4, label %cond1, label %endloop1
cond1:
    %r5 = load i32* %a
    %r6 = load i32* %b
    %r7 = mul i32 %r5, %r6
    store i32 %r7, i32* %a
    %r8 = load i32* %b
    %r9 = add i32 1, 0
    %r10 = sub i32 %r8, %r9
    store i32 %r10, i32* %b
    br label %loop1
endloop1:
%r11 = load i32* %a
call i32 @putsI(i32 %r11)

\end{verbatim}
\end{minipage}

\vspace{0.5cm}

Ce code affiche le nombre $120$ correspondant bien à $5!$ .

\section{Génération de code}

\section{Limitations}

\subsection{Non supporté}
\begin{itemize}
	\item Pas de gestion de classes mais une base solide pour l'implémenter.
	\item Pas de prise en charge des chaines de caractères. Nous savons cependant qu'elles devront être déclarées commes des constantes globales dans l'assembleur llvm.
\end{itemize}

\subsection{Améliorations envisagées}
\begin{itemize}
	\item Suppression de l'initialisation de registres avec des constantes via des opérations du type \verb!r = add 5, 0! pour l'initialisation de nombres ou \verb!r = or true, false! pour l'initialisation de booléens.
	\item Le support des classes devrait rendre plus robuste les calculs sur les types qui n'ont pu être testés qu'avec les nombres et les booléens.
\end{itemize}

\section{Conclusion}

Les objectifs du projet n'ont pas tous été remplis mais nous avons concentré nos efforts sur une représentation simple et flexible des instructions pour fournir les fondations du support des classes.

Ce projet a permis le développement et la mise en œuvre de nombreuses
compétences intéressantes telles que l'utilisation des outils Flex et Yacc, la
découverte du langage Ruby, l'initiation au langage LLVM et l'utilisation de
structures de données adaptées au typage des données, à la gestion des tables
de symboles et de la mémoire.


\end{document}
