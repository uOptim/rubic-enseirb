\documentclass[12pt]{article}

\usepackage{geometry}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[frenchb]{babel}

\usepackage{graphicx}
\usepackage{lmodern}

\geometry{margin=2cm}


\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\thispagestyle{empty}
\noindent\includegraphics[width=0.25\textwidth]{enseirb-matmeca}

\vspace{\stretch{1}}

\begin{center}
    {\Huge\textbf{Projet de compilation}

\vspace{\stretch{1}}

    \textbf{Rubic}}
\end{center}

\vspace{\stretch{2}}

\begin{tabular}{r@{:~}l}
	\textbf{Auteurs} & \textit{David Bitonneau, Benoît Ruelle}\\
	\textbf{Encadrant} & \textit{M. Denis Barthou}\\
\end{tabular}

\vspace{\stretch{1}}

\begin{center}Deuxième année, filière informatique

    Date : \today
\end{center}

\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

Ce projet a pour but de créer un compilateur pour le langage Rubic, un dérivé
simplifié du langage Ruby. Le code généré est un code assembleur intermédiaire
portable pour LLVM. Pour ce projet, une grande attention a été portée à la flexibilité de manière à pouvoir améliorer facilement le compilateur sans nous limiter aux seules fonctionnalités citées sur la page du sujet.

\section{Langage Rubic}

En Ruby les noms de variables sont des étiquettes sans type et ce sont les
objets qu'elles contiennent qui sont fortement et dynamiquement typé. Il n'y a
donc pas de vérification de typage statique et c'est à l'exécution qu'il est
vérifié si l'appel de méthode fonctionne pour l'objet traité. Une même
variable peut donc contenir des objets de types différents au cours de sa vie.

En Rubic, le typage n'est pas dynamique mais il est implicite. Une des
difficultés du projet est de savoir reconnaître le type des variables et de
générer le code statique correspondant.

\paragraph{} En Rubic il existe différents types de variables :
\begin{itemize}
    \item les nombres entiers ;
    \item les nombres flottants ;
    \item les booléens ;
    \item les chaînes de caractères ;
    \item les objets\footnote{En Ruby tout est un objet, même les classes et
        les entiers.}.
\end{itemize}

\paragraph{}
Ces variables peuvent avoir différentes portées :
\begin{itemize}
    \item Les variables qui commencent par un '\$' sont des variables
        globales, elles sont accessibles partout une fois qu'elles ont été
        définies.
    \item Les variables qui commencent par un '@' sont des variables
        d'instances, leur portée est limitée à l'objet et elles ne peuvent
        être accédées à l'extérieur que via des méthodes.
    \item Les autres variables sont locales aux environnements auxquelles
        elles appartiennent. Par exemple elles peuvent être locale à la
        fonction dans laquelle elles ont été définies ou si elles ont été
        définies à l'extérieur de toute fonction ou classe, elles ne peuvent
        être accédées à l'intérieur de ces dernière.
\end{itemize}

\paragraph{}
Enfin, par convention, les variables dont le nom commence par une majuscule sont des constantes. En Ruby, leur modification entraine seulement l'affichage d'un avertissement et est effective. En Rubic nous avons pris la même décision, seul une message d'avertissement est affiché lorsque des constantes sont modifiées et la compilation s'achèvera normalement.


\section{Analyse sémantique}

La grammaire nous étant fournie, la majorité du travail fut de rajouter des
actions sémantique dans le parser. Nous avons tout de même complété la
grammaire pour inclure les booléens et les commentaires par exemple.

\subsection{Piles}

La grande majorité des éléments manipulés sont stockés dans des piles. Des opération d'union, d'intersection, d'itération sur des ensembles stockés dans les piles ont été implémentées. Dans le projet, elles ont servie notamment à représenter les portées des variables, une liste de type par chaque variable ou bien une liste d'instruction à trier puis à générer.


\subsection{Tables de hashage}

Notre compilateur propose trois espaces de noms : un pour les
variables, un autre pour les fonctions et un dernier pour les classes. Cela
permet à une variable de coexister avec une classe ou une fonction du même
nom. Chaque espace de nom est implémenté à l'aide d'une table de hashage dont
le fonctionnement est le suivant.

Deux éléments sont demandés : un identificateur et un pointeur vers une donnée.
Une clé est obtenue en sommant tous les octets de l'identificateur modulo la
taille de la table de hashage (constante fixée à la compilation). Pour prendre
en charge les éventuelles collisions, à chaque case de la table correspond une
liste chaînée (une LIFO pour réutiliser ce qui a déjà été implémenté) où sont
insérés les données ayant la même clé (eg. "toto" et "otto" produisent la même
clé) et les identifiants avant le hashage sont alors conservés dans la liste
pour distinguer deux éléments lors de la recherche. La recherche est alors
simple : à partir de l'identifiant recherché, reproduire la clé et parcourir
la liste dans la case de la table de hashage correspondante.


\subsection{Visibilité des symboles}

La visibilité des symboles a été prise en charge à l'aide d'une pile et d'une
structure appelée "block" comprenant trois tables de hashage (une par espace
de nom). Un nouveau bloc est empilé à chaque fois qu'un lexème définissant une
nouvelle visibilité est lu.

La recherche d'un symbole se fait en parcourant la pile pour
tester sa présence dans la table de hashage du type correspondant dans chaque
bloc.

\subsection{Reconnaissance et calculs sur les types}

\paragraph{} Nous avons développé un jeu de fonctions décrivant un langage intermédiaire
proche de l'assembleur LLVM dont l'intérêt est multiple. Ce jeu d'instructions
permet de manipuler le code à générer en faisant abstraction temporairement
des types des variables. Cela simplifie la génération de toutes les variantes
d'une fonction possible en fonction du type de ses paramètres et cela pose une
base sur laquelle construire le support des classes.

Ce jeu d'instruction manipule trois structures différentes :
\begin{itemize}
	\item Les constantes obtenues via les tokens STRING, FLOAT, BOOL, INT
	\item Les registres qui correspondent à un registre dans LLVM.
	\item Les variables repérées par le token ID de certaines règles (affectation, paramètres, etc).
\end{itemize}

\paragraph{} Les types possibles pour chaque variables sont calculés au fur et à mesure que
le code est lu en se basant sur les opérations dans lesquelles elles
apparaissent. Ainsi, un pointeur vers une variable apparaît dans une série
d'instructions. Parmi elles, certaines nous permettent de réaliser des
calculs sur les types. Par exemple, l'emploi d'une variable avec l'opérateur
'+' permet de réduire cet ensemble aux types entier et flottant. Nous avons défini plusieurs sortes d'instructions :
\begin{itemize}
	\item Celles définissant des opérations sur des variables ou des registres
		telles que les additions ou les comparaisons.
	\item Celles pouvant insérer des instructions supplémentaires lors de la
		génération du code suivant le types d'une variable ou d'un registre.
		Nous les utilisons par exemple pour convertir un entier en booléen
		lorsqu'il est utilisé dans une condition.
	\item Celles qui stockent simplement une chaîne de caractères à imprimer
		(utilisé pour le placement de labels par exemple).
	\item Celles permettant d'établir un lien entre des registres et une
		variables (load et store).
\end{itemize}

\paragraph{} Les registres peuvent être liés une unique fois à une variable
lors d'un 'store' ou d'un 'load'. Ils partagent alors avec la variable
l'ensemble des types possible et les déductions sur le type de l'un affectera
dans le même temps celui de l'autre. Ainsi, toutes les instructions ayant un
lien direct avec une variable ou l'un de des registres qui lui sont liés sont
affectées et l'ensemble des variations du code final à générer est réduit.

\subsection{Structures de contrôle}

\paragraph{} En Ruby, les structures de contrôles ne définissent pas un bloc séparé de la fonction et il est donc nécessaire de repérer les variables introduites dans ces blocs (qui sont d'ailleurs exécutés sous conditions) pour allouer l'espace nécessaire en début de fonction. Si nous ne faisions pas cela, cela engendrerait une erreur de compilation de LLVM due aux allocations soumises à condition.

\paragraph{} Dans une première version du compilateur, nous avons tenté de gérer proprement le problème en forçant la déclaration des variables en dehors des structures de contrôle à l'aide de blocs définissant une nouvelle portée. Cependant, après l'introduction de notre jeu d'instruction intermédiaire nous pouvions désormais réordonner les actions à loisir. Ainsi, nous avons rendu possible la déclaration de variables dans une structure de contrôle. Il suffit pour cela de stocker dans l'ordre les instructions rencontrées dans une fonction et de mettre au début toutes celles faisant des allocations lors de la génération de l'assembleur LLVM.

\paragraph{Exemple} Code original et code généré

\vspace{0.5cm}

\begin{minipage}{0.48\textwidth}
\begin{verbatim}
if true then
    a = 1
else
    b = 5
end
\end{verbatim}
\end{minipage}
\begin{minipage}{0.48\textwidth}
\begin{verbatim}
%a = alloca i32
%b = alloca i32
%r1 = or i1 true, false
br i1 %r1, label %IfTrue1, label %IfFalse1
IfTrue1:
    %r2 = add i32 1, 0
    store i32 %r2, i32* %a
    br label %EndIf1
IfFalse1:
    %r3 = add i32 5, 0
    store i32 %r3, i32* %b
    br label %EndIf1
EndIf1:
\end{verbatim}
\end{minipage}

\vspace{0.5cm}

En testant la valeur de \verb!a! et de \verb!b!, \verb!a! vaut \verb!1! et \verb!b! vaut \verb!0!. LLVM semble initialiser la mémoire à 0 lors d'allocations.

\subsection{Conversion vers les booléens}

Lors de l'utilisation de variables ou de constantes dans une expression servant de condition à une structure de contrôle, il peut être nécessaire de convertir un entier ou un flottant en booléen. Nous voulions qu'un nombre valant 0 soit assimilé à faux et tous les autres (y compris les nombres négatifs) à vrai. La détection du besoin de réaliser une conversion se fait en fonction du type d'expression rencontrée : une opération booléenne bit à bit ou une comparaison de nombres garantit de retourner un booléen. En revanche une expression retournant un nombre nécessite une conversion explicite et une opération de conversion est insérée. Cette dernière entraîne la création d'un nouveau registre dans l'assembleur LLVM qui est substitué au registre de l'expression initiale lors du test de la structure de contrôle.

\paragraph{Exemple} Code original et code généré

\vspace{0.5cm}

\begin{minipage}{0.48\textwidth}
\begin{verbatim}
b = 5
a = 1

while b
    a = a*b
    b = b - 1
end

puts a
\end{verbatim}
\end{minipage}
\begin{minipage}{0.48\textwidth}
\begin{verbatim}
%b = alloca i32
%a = alloca i32
%r1 = add i32 5, 0
store i32 %r1, i32* %b
%r2 = add i32 1, 0
store i32 %r2, i32* %a
br label %loop1
loop1:
    %r3 = load i32* %b
    %r4 = icmp ne i32 %r3, 0
    br i1 %r4, label %cond1, label %endloop1
cond1:
    %r5 = load i32* %a
    %r6 = load i32* %b
    %r7 = mul i32 %r5, %r6
    store i32 %r7, i32* %a
    %r8 = load i32* %b
    %r9 = add i32 1, 0
    %r10 = sub i32 %r8, %r9
    store i32 %r10, i32* %b
    br label %loop1
endloop1:
%r11 = load i32* %a
call i32 @putsI(i32 %r11)

\end{verbatim}
\end{minipage}

\vspace{0.5cm}

Ce code affiche le nombre $120$ correspondant bien à $5!$ .

\paragraph{} De même, ces instructions sont correctement prises en compte:

\vspace{0.5cm}

\begin{minipage}{0.48\textwidth}
\begin{verbatim}
b = 5.2

if b then
...
end

if (b && false) then
...
end
\end{verbatim}
\end{minipage}
\begin{minipage}{0.48\textwidth}
\begin{verbatim}
if (0 || true) then
...
end
\end{verbatim}
\end{minipage}

\vspace{0.5cm}


\section{Les classes}

Les classes ne sont pas prises en compte bien qu'elles soient reconnues et mémorisées dans le parser. Leur introduction aurait été réalisée selon les idées suivantes.

Une classe définit un nouveau type qui est alors ajouté à la liste des types possibles pour les paramètres d'une fonction. Une fonction faisant partie d'une classe aurait vu son nom altéré par un préfixe lors de l'opération de mangling (voir ci après) et celle-ci aurait eu un paramètre implicite ajouté du type de la classe. Ansi, si la variable \verb!a! est du type \verb!A!, \verb!a.f(p1, p2)! provoquerait l'appel à la fonction \verb!f_apres_mangling(a, p1, p2)!.

\section{Génération de code}

Le l'objectif principal était de produire du code assembleur LLVM à partir de code Rubic. Cependant, les variables n'étant pas explicitement typées, la génération de code à la volée\footnote{c'est-à-dire, au moment où le code Rubic est parsé} n'est possible que dans les cas très simple où le type des variables est connu au moment où on rencontre l'instruction.

\paragraph{Exemple} Code dont le type des variables peut être déterminé à la volée
\begin{verbatim}
a = 1           # a est un entier
b = a + 1.2     # b est un nombre flottant
\end{verbatim}

\paragraph{Exemple} Code dont le type des variables ne peut pas être déterminé à la volée
\begin{verbatim}
def f(a)
    b = a       # les types de a et b sont inconnus
    return b
end 
\end{verbatim}

La solution employée consistant à stocker une représentation abstraite des instructions permet de résoudre ce problème.

\subsection{Les fonctions}

Le problème de la détermination du type des variables se manifeste particulièrement dans les fonctions. En effet, lorsque la définition d'une fonction est rencontrée, le type de ses paramètres n'est pas connu et par conséquent le type de retour éventuel et ceux des variables locales à la fonction peut également être indéterminé.

Différentes implémentations d'une même fonction peuvent donc exister selon les types donnés à ses paramètres. Ce qui signifie que la rencontre de la définition d'une fonction peut mener à la génération de plusieurs codes différents pour cette fonctions. Il est donc particulièrement utile dans ce cas de pouvoir stocker une représentation intermédiaire de la définition de la fonction afin de générer différent codes par la suite.

Pour déterminer le code à générer deux solutions s'offraient à nous :
\begin{itemize}
	\item Essayer de générer le code en ce basant sur les appels à cette fonction. 
	\item Générer tous les codes possibles suivant les types des paramètres.
\end{itemize}

\paragraph{Exemple} Illustration de ces deux choix
\begin{verbatim}
def f(a, b)
    return a + b
end 

f(1, 2.3)
f(67, 23)
\end{verbatim}

Avec la première solution, seules deux implémentations de la fonction \verb!f! vont être générées : l'une prenant respectivement un entier et un flottant en paramètres, l'autre prenant deux entiers en paramètres.
Avec la deuxième solution, chaque paramètre peut être un entier ou un flottant donc $2^{2} = 4$ implémentations différentes seront générées.

La première approche a l'avantage de de générer que le code nécessaire pour le fichier donné. Un binaire prenant moins de place mémoire est donc créé.
La deuxième approche est plus puissante, elle permet par exemple de pouvoir écrire une bibliothèque de fonctions en Rubic, dont l'ensemble des implémentations possibles pour chaque fonction sera généré, malgré l'absence d'appel à celle-ci.

Nous avons choisi la deuxième solution pour sa puissance et malgré l'occupation mémoire supplémentaire. Cette solution a également l'avantage de pouvoir générer le code de la fonction au moment où on rencontre la fin de sa définition, sans ce soucier du reste du code.

Cependant, pour éviter une explosions combinatoire des types et des codes générés pour une fonction donnée, il est nécessaire de restreindre au plus tôt les types possibles des paramètres de la fonction.

\subsubsection{Calcul des types des paramètres}

\subsubsection{après le calcul des types, le calcul des combinaisons... hoho}

-> algo de combinaison des types : un gros merdier
 pourquoi qu'on a foutu des piles de paramètres nous ?

\subsubsection{Mangling}

Inspiré du  C++

La signature de la fonction y est stocké
le type de retour est déterminé par les types des paramètres en entrée

\subsection{Détection erreur de type}

si le mec file des types qui vont pas, on lui gueule dessus
ex : "CONNARD, tu vas pas additionner des patates et des carottes"

\subsection{Appel de fonction}

\subsection{calcul complémentaire sur les types}
(ouai parce que là on n'a pas encore tout déterminé)


\section{Utilisation}

Un makefile à la racine permet de compiler le projet et de placer les binaires aux bons endroit. Une invocation du script \verb!rubic -o dest fichier.rb! permet de compiler \verb!fichier.rb! et de générer l'exécutable \verb!dest! correspondant.


\section{Tests et limitations}

\subsection{Tests}

Plusieurs fichiers de tests illustrant les fonctionnalités sur compilateur se trouvent dans le répertoire 'tests'. L'ensemble des tests sont compilés sans fuite de mémoire d'après valgrind (excepté pour les tests préliminaires sur les appels de fonction).

\subsection{Non supporté}
\begin{itemize}
	\item Pas de variables globales avec le préfixe \verb!$!.
	\item Pas de gestion de classes mais une base solide pour l'implémenter.
	\item Pas de prise en charge des chaines de caractères. Nous savons cependant qu'elles devront être déclarées comme des constantes globales dans l'assembleur LLVM.
\end{itemize}

\subsection{Améliorations envisagées}
\begin{itemize}
	\item Suppression de l'initialisation de registres avec des constantes via des opérations du type \verb!r = add 5, 0! pour l'initialisation de nombres ou \verb!r = or true, false! pour l'initialisation de booléens.
	\item Le support des classes devrait rendre plus robuste les calculs sur les types qui n'ont pu être testés qu'avec les nombres et les booléens.
\end{itemize}

\section{Conclusion}

Ce projet a permis le développement et la mise en œuvre de nombreuses compétences intéressantes telles que l'utilisation des outils Lex et Yacc, la découverte du langage Ruby, la découverte de LLVM et l'utilisation de structures de données adaptées au typage des données, à la gestion des tables de symboles et de la mémoire.

Les objectifs du projet n'ont pas tous été remplis mais nous avons concentré nos efforts sur une représentation simple et flexible des instructions pour fournir les fondations du support des classes. Il en ressort que certains éléments simples n'ont pas été implémentés et beaucoup de temps a été consacré au développement de manipulations puissantes pas explicitement demandées dans le sujet mais qui nous ont tout de même beaucoup intéressé.

Ce projet a également mis en lumière les problèmes que l'on peut rencontrer lors de la génération d'un code statique pour un langage à types implicites et nous a aidé à comprendre les choix pour la syntaxe d'autres langages ou l'intérêt qu'ont les interpréteurs dans certaines situations. En résumé, ces premiers pas dans la création d’un compilateur nous ont beaucoup plu même si l'on regrettera d'avoir manqué de temps pour construire d'avantage de fonctionnalités sur les bases mises en place.



\end{document}
